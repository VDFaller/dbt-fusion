// This file is @generated by prost-build.
/// Top-level event for reporting a build phase, with optional details.
#[derive(crate::macros::ProtoNew)]
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[::serde_with::skip_serializing_none]
#[derive(::serde::Serialize)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PhaseExecuted {
    /// The current phase of execution.
    #[prost(enumeration = "ExecutionPhase", tag = "1")]
    #[serde(
        serialize_with = "ExecutionPhase::serialize",
        deserialize_with = "ExecutionPhase::deserialize"
    )]
    #[cfg_attr(
        any(test, feature = "test-utils"),
        dummy(expr = "::fake::Fake::fake::<ExecutionPhase>(&::fake::Faker) as i32")
    )]
    pub phase: i32,
    /// Optional count of total individual nodes within the phase (when applicable).
    #[prost(uint64, optional, tag = "2")]
    pub node_count_total: ::core::option::Option<u64>,
    /// Optional count of skipped nodes within the phase (when applicable).
    /// Skipped means `node_outcome` was set to `NODE_OUTCOME_SKIPPED`.
    #[prost(uint64, optional, tag = "3")]
    pub node_count_skipped: ::core::option::Option<u64>,
    /// Optional count of errored nodes within the phase (when applicable).
    /// Error means `node_outcome` was set to `NODE_OUTCOME_ERROR`.
    #[prost(uint64, optional, tag = "4")]
    pub node_count_error: ::core::option::Option<u64>,
}
impl crate::StaticName for PhaseExecuted {
    const FULL_NAME: &'static str = "v1.public.events.fusion.phase.PhaseExecuted";
    const TYPE_URL: &'static str = "/v1.public.events.fusion.phase.PhaseExecuted";
}
impl ::prost::Name for PhaseExecuted {
    const NAME: &'static str = "PhaseExecuted";
    const PACKAGE: &'static str = "v1.public.events.fusion.phase";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.phase.PhaseExecuted".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.phase.PhaseExecuted".into()
    }
}
/// A superset of all possible phases across all dbt commands.
/// Note that not all phases are relevant to all commands.
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[derive(crate::macros::ProtoEnumSerde)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExecutionPhase {
    /// Do not use.
    Unspecified = 0,
    /// Cleaning output folders (e.g. the target directory)
    Clean = 10,
    /// dbt Project loading: analyzing dbt_project, profiles.yml and scanning files
    LoadProject = 20,
    /// Parsing and macro name resolution of all dbt files
    Parse = 30,
    /// Schedule nodes based on selection criteria and dependencies.
    Schedule = 40,
    /// Initializing the adapter (warehouse connection and configuration)
    InitAdapter = 50,
    /// Handling deferral. Fetching state source schemas from remote, hydrating relation, and schema cache
    DeferHydration = 60,
    /// Building the task graph from the schedule
    TaskGraphBuild = 70,
    /// Hydration of cached models, seeds, snapshots and sources
    NodeCacheHydration = 80,
    /// Render SQL (also called `compile` in dbt core)
    Render = 90,
    /// SQL static analysis
    Analyze = 100,
    /// Execution against the target database
    Run = 110,
    /// Freshness analysis of sources and models
    FreshnessAnalysis = 120,
    /// Analysis of individual node lineages
    Lineage = 130,
    /// Debugging connection correctness and availability to the warehouse
    Debug = 140,
}
impl ExecutionPhase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EXECUTION_PHASE_UNSPECIFIED",
            Self::Clean => "EXECUTION_PHASE_CLEAN",
            Self::LoadProject => "EXECUTION_PHASE_LOAD_PROJECT",
            Self::Parse => "EXECUTION_PHASE_PARSE",
            Self::Schedule => "EXECUTION_PHASE_SCHEDULE",
            Self::InitAdapter => "EXECUTION_PHASE_INIT_ADAPTER",
            Self::DeferHydration => "EXECUTION_PHASE_DEFER_HYDRATION",
            Self::TaskGraphBuild => "EXECUTION_PHASE_TASK_GRAPH_BUILD",
            Self::NodeCacheHydration => "EXECUTION_PHASE_NODE_CACHE_HYDRATION",
            Self::Render => "EXECUTION_PHASE_RENDER",
            Self::Analyze => "EXECUTION_PHASE_ANALYZE",
            Self::Run => "EXECUTION_PHASE_RUN",
            Self::FreshnessAnalysis => "EXECUTION_PHASE_FRESHNESS_ANALYSIS",
            Self::Lineage => "EXECUTION_PHASE_LINEAGE",
            Self::Debug => "EXECUTION_PHASE_DEBUG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXECUTION_PHASE_UNSPECIFIED" => Some(Self::Unspecified),
            "EXECUTION_PHASE_CLEAN" => Some(Self::Clean),
            "EXECUTION_PHASE_LOAD_PROJECT" => Some(Self::LoadProject),
            "EXECUTION_PHASE_PARSE" => Some(Self::Parse),
            "EXECUTION_PHASE_SCHEDULE" => Some(Self::Schedule),
            "EXECUTION_PHASE_INIT_ADAPTER" => Some(Self::InitAdapter),
            "EXECUTION_PHASE_DEFER_HYDRATION" => Some(Self::DeferHydration),
            "EXECUTION_PHASE_TASK_GRAPH_BUILD" => Some(Self::TaskGraphBuild),
            "EXECUTION_PHASE_NODE_CACHE_HYDRATION" => Some(Self::NodeCacheHydration),
            "EXECUTION_PHASE_RENDER" => Some(Self::Render),
            "EXECUTION_PHASE_ANALYZE" => Some(Self::Analyze),
            "EXECUTION_PHASE_RUN" => Some(Self::Run),
            "EXECUTION_PHASE_FRESHNESS_ANALYSIS" => Some(Self::FreshnessAnalysis),
            "EXECUTION_PHASE_LINEAGE" => Some(Self::Lineage),
            "EXECUTION_PHASE_DEBUG" => Some(Self::Debug),
            _ => None,
        }
    }
}
