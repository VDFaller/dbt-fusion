// This file is @generated by prost-build.
/// Adapter Info Event is responsible for foundational adapter information.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdapterInfo {
    /// This field is a toggle to enable enrichment of the message by the Vortex service.
    #[prost(message, optional, tag = "1")]
    pub enrichment: ::core::option::Option<
        super::super::super::events::vortex::VortexMessageEnrichment,
    >,
    /// event_id is the unique identifier for this event. It is a generated UUID.
    #[prost(string, tag = "2")]
    pub event_id: ::prost::alloc::string::String,
    /// A foreign key to the Invocation message that was emitted at the
    /// start of the fusion process.
    /// Required.
    #[prost(string, tag = "3")]
    pub invocation_id: ::prost::alloc::string::String,
    /// adapter_type is the plain string name for the dbt adapter that's used by the
    /// project. Examples could include: "bigquery", "snowflake", "redshift", "postgres", etc.
    #[prost(string, tag = "4")]
    pub adapter_type: ::prost::alloc::string::String,
    /// adapter_unique_id is the unique identifier of a project's warehouse credentials.
    /// For supported warehouses, we create an MD5 hash of the connection string.
    /// The specific string varies per adapter_type.
    #[prost(string, tag = "5")]
    pub adapter_unique_id: ::prost::alloc::string::String,
}
impl ::prost::Name for AdapterInfo {
    const NAME: &'static str = "AdapterInfo";
    const PACKAGE: &'static str = "v1.public.events.fusion";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.AdapterInfo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.AdapterInfo".into()
    }
}
/// Adapter Info V2 Event was created when we needed to collect more information
/// about the adapter. Unlike AdapterInfo above, this event is tied to RunModel
/// events. Here we're able to collect adapter-specific information at the
/// individual model level. This was first created when we started to collect
/// information on which models were Iceberg-powered.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdapterInfoV2 {
    /// This field is a toggle to enable enrichment of the message by the Vortex service.
    #[prost(message, optional, tag = "1")]
    pub enrichment: ::core::option::Option<
        super::super::super::events::vortex::VortexMessageEnrichment,
    >,
    /// event_id is the unique identifier for this event. It is a generated UUID.
    #[prost(string, tag = "2")]
    pub event_id: ::prost::alloc::string::String,
    /// A foreign key to the RunModel message that was emitted at each instance
    /// of an individual model being run.
    #[prost(string, tag = "3")]
    pub run_model_id: ::prost::alloc::string::String,
    /// This reflects the adapter name used when they ran a given model.
    #[prost(string, tag = "4")]
    pub adapter_name: ::prost::alloc::string::String,
    /// This reflects the simplified semantic version of an adapter that was used
    /// when they ran a given model. ex. 1.9.0
    #[prost(string, tag = "5")]
    pub base_adapter_version: ::prost::alloc::string::String,
    /// This reflects the full adapter version used when they ran a given model.
    #[prost(string, tag = "6")]
    pub adapter_version: ::prost::alloc::string::String,
    /// This is a flexible key-value pair that can be used to store any additional
    /// model adapter information. Today this is used to store two pieces of
    /// information: the model_adapter_type (the adapter_name that was used for
    /// that specific model) and the model_adapter_table_format (Iceberg or
    /// something else).
    #[prost(map = "string, string", tag = "7")]
    pub model_adapter_details: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
impl ::prost::Name for AdapterInfoV2 {
    const NAME: &'static str = "AdapterInfoV2";
    const PACKAGE: &'static str = "v1.public.events.fusion";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.AdapterInfoV2".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.AdapterInfoV2".into()
    }
}
/// Invocation Event is emitted by dbt when a user runs a command and begins to
/// emit basic environment information out that can be referred to later on by
/// other events that are emitted. This event then fires off a second time when
/// the invocation has completed. Upon completion, we get more information about
/// the end state of this action.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Invocation {
    /// This field is a toggle to enable enrichment of the message by the Vortex service.
    #[prost(message, optional, tag = "1")]
    pub enrichment: ::core::option::Option<
        super::super::super::events::vortex::VortexMessageEnrichment,
    >,
    /// event_id is the unique identifier for this event. It is a generated UUID.
    /// Required.
    #[prost(string, tag = "2")]
    pub event_id: ::prost::alloc::string::String,
    /// This is the globally unique identifier for this invocation event.
    /// It is emitted once during the lifetime of the fusion process at the
    /// beginning and referred to by other messages using this ID.
    /// Required.
    #[prost(string, tag = "3")]
    pub invocation_id: ::prost::alloc::string::String,
    /// project_id is the MD5 hash of the project name that's supplied in the
    /// dbt_project.yml file. This is originally the primary identifier for our anonymous
    /// usage tracking. Today we couple this with the AdapterInfo adapter_unique_id.
    #[prost(string, tag = "4")]
    pub project_id: ::prost::alloc::string::String,
    /// user_id is the UUID generated to identify a unique user. We store a cookie
    /// or token in the user's local directory which we use to maintain user information
    /// across sessions. This is usually found in ~/.dbt/.user.yml.
    #[prost(string, tag = "5")]
    pub user_id: ::prost::alloc::string::String,
    /// The full string of the command that was run.
    #[prost(string, tag = "6")]
    pub command: ::prost::alloc::string::String,
    /// A string that indicates whether the event represents the start or end of an
    /// invocation. The valid values for this are:
    ///
    ///   start
    ///   end
    ///   invalid
    ///   ok
    ///
    #[prost(string, tag = "7")]
    pub progress: ::prost::alloc::string::String,
    /// The version of dbt that was used to run this command.
    #[prost(string, tag = "8")]
    pub version: ::prost::alloc::string::String,
    /// The exit state of an invocation's start or end event. The valid values for this are:
    ///
    ///   started
    ///   ok
    ///   invalid_profile
    ///   error
    ///
    #[prost(string, tag = "9")]
    pub result_type: ::prost::alloc::string::String,
    /// The SHA of the git commit of the dbt project being run if it is found.
    /// If there are changes that aren't committed we may also want to have a
    /// git_commit_dirty boolean to indicate there are some staged or unstaged
    /// changes.  In the RunModel message there is also a hashed_contents which
    /// gives a hash of the model being run which may be finer granularity than
    /// at a project level.
    #[prost(string, tag = "10")]
    pub git_commit_sha: ::prost::alloc::string::String,
}
impl ::prost::Name for Invocation {
    const NAME: &'static str = "Invocation";
    const PACKAGE: &'static str = "v1.public.events.fusion";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.Invocation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.Invocation".into()
    }
}
/// Invocation Environment Event is the primary way we are able to associate
/// invocation telemetry data with our dbt Cloud information. Values are supplied
/// here whenever dbt is run in a cloud environment.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvocationEnv {
    /// This field is a toggle to enable enrichment of the message by the Vortex service.
    #[prost(message, optional, tag = "1")]
    pub enrichment: ::core::option::Option<
        super::super::super::events::vortex::VortexMessageEnrichment,
    >,
    /// event_id is the unique identifier for this event. It is a generated UUID.
    #[prost(string, tag = "2")]
    pub event_id: ::prost::alloc::string::String,
    /// A foreign key to the Invocation message that was emitted at the
    /// start of the fusion process.
    #[prost(string, tag = "3")]
    pub invocation_id: ::prost::alloc::string::String,
    /// This is a string that indicates the environment in which the invocation is
    /// running. Our primary use case here is to pass along dbt Cloud context with
    /// the invocation event so we can associate the invocation with a specific
    /// dbt Cloud activity and account. Different cloud services have used different
    /// string formats and IDs provided.
    #[prost(string, tag = "4")]
    pub environment: ::prost::alloc::string::String,
}
impl ::prost::Name for InvocationEnv {
    const NAME: &'static str = "InvocationEnv";
    const PACKAGE: &'static str = "v1.public.events.fusion";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.InvocationEnv".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.InvocationEnv".into()
    }
}
/// Package Install Event is emitted when dbt deps (or other commands that
/// trigger packages to be installed) is run.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackageInstall {
    /// This field is a toggle to enable enrichment of the message by the Vortex service.
    #[prost(message, optional, tag = "1")]
    pub enrichment: ::core::option::Option<
        super::super::super::events::vortex::VortexMessageEnrichment,
    >,
    /// event_id is the unique identifier for this event. It is a generated UUID.
    #[prost(string, tag = "2")]
    pub event_id: ::prost::alloc::string::String,
    /// A foreign key to the Invocation message that was emitted at the
    /// start of the fusion process.
    #[prost(string, tag = "3")]
    pub invocation_id: ::prost::alloc::string::String,
    /// plain string name of a pakage that was installed. This is often the same
    /// or similar to the git repository name of that package.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// plain string source of the package. This is also referred to as the
    /// installation method in our internal analytics. This is based on the syntax
    /// used in packages.yml file.
    #[prost(string, tag = "5")]
    pub source: ::prost::alloc::string::String,
    /// either a semantic version of the package (if installed through the hub) or
    /// a git commit hash (if installed through git).
    #[prost(string, tag = "6")]
    pub version: ::prost::alloc::string::String,
}
impl ::prost::Name for PackageInstall {
    const NAME: &'static str = "PackageInstall";
    const PACKAGE: &'static str = "v1.public.events.fusion";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.PackageInstall".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.PackageInstall".into()
    }
}
/// Resource Counts Events fire after an invocation event to give a count of all
/// the resources that were used in the invocation. Note that this includes all
/// the resources in the active project, including those from installed packages
/// and (in the case of macros) from the global dbt project. This will show all
/// resources available, regardless of if they are run or not.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceCounts {
    /// This field is a toggle to enable enrichment of the message by the Vortex service.
    #[prost(message, optional, tag = "1")]
    pub enrichment: ::core::option::Option<
        super::super::super::events::vortex::VortexMessageEnrichment,
    >,
    /// event_id is the unique identifier for this event. It is a generated UUID.
    #[prost(string, tag = "2")]
    pub event_id: ::prost::alloc::string::String,
    /// A foreign key to the Invocation message that was emitted at the
    /// start of the fusion process.
    #[prost(string, tag = "3")]
    pub invocation_id: ::prost::alloc::string::String,
    /// total count of models in the project.
    #[prost(int32, tag = "4")]
    pub models: i32,
    /// total count of data tests (originally just tests) in the project.
    #[prost(int32, tag = "5")]
    pub tests: i32,
    /// total count of snapshots in the project.
    #[prost(int32, tag = "6")]
    pub snapshots: i32,
    /// total count of analysis queries in the project.
    #[prost(int32, tag = "7")]
    pub analyses: i32,
    /// total count of macros in the project.
    #[prost(int32, tag = "8")]
    pub macros: i32,
    /// total count of operations in the project.
    #[prost(int32, tag = "9")]
    pub operations: i32,
    /// total count of seeds in the project.
    #[prost(int32, tag = "10")]
    pub seeds: i32,
    /// total count of sources in the project.
    #[prost(int32, tag = "11")]
    pub sources: i32,
    /// total count of exposures in the project.
    #[prost(int32, tag = "12")]
    pub exposures: i32,
    /// total count of metrics in the project.
    #[prost(int32, tag = "13")]
    pub metrics: i32,
    /// total count of groups in the project.
    #[prost(int32, tag = "14")]
    pub groups: i32,
    /// total count of unit tests in the project.
    #[prost(int32, tag = "15")]
    pub unit_tests: i32,
    /// total count of semantic models in the project.
    #[prost(int32, tag = "16")]
    pub semantic_models: i32,
    /// total count of saved queries in the project.
    #[prost(int32, tag = "17")]
    pub saved_queries: i32,
}
impl ::prost::Name for ResourceCounts {
    const NAME: &'static str = "ResourceCounts";
    const PACKAGE: &'static str = "v1.public.events.fusion";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.ResourceCounts".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.ResourceCounts".into()
    }
}
/// Run Model Event will be emitted when Fusion runs a model or skips a model because
/// it determines it does not need to be run. The Account Identifier and Project Identifier
/// can be found by joining this message on the Invocation message specified in the invocation_id
/// field.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunModel {
    /// This field is a toggle to enable enrichment of the message by the Vortex service.
    #[prost(message, optional, tag = "1")]
    pub enrichment: ::core::option::Option<
        super::super::super::events::vortex::VortexMessageEnrichment,
    >,
    /// event_id is the unique identifier for this event. It is a generated UUID.
    #[prost(string, tag = "2")]
    pub event_id: ::prost::alloc::string::String,
    /// A foreign key to the Invocation message that was emitted at the
    /// start of the fusion process.
    #[prost(string, tag = "3")]
    pub invocation_id: ::prost::alloc::string::String,
    /// the numerical index of that model with respect to the total models being run
    #[prost(int32, tag = "4")]
    pub index: i32,
    /// the total number of models being run in this invocation
    #[prost(int32, tag = "5")]
    pub total: i32,
    /// the time it took for a model to execute in seconds. This should mirror what
    /// is displayed in the dbt output logs next to each model.
    #[prost(double, tag = "6")]
    pub execution_time: f64,
    /// success or failure status of that model's run. This mirrors what is displayed
    /// in the dbt output logs next to each model. Ex. "SUCCESS 1", "INSERT 1", "INSERT 23", etc.
    #[prost(string, tag = "7")]
    pub run_status: ::prost::alloc::string::String,
    /// whether or not the model was skipped. If the run was skipped the reason it was
    /// skipped is indicated by the value of the run_skipped_reason field.
    #[prost(bool, tag = "8")]
    pub run_skipped: bool,
    /// the materialization strategy used for that model
    #[prost(string, tag = "9")]
    pub model_materialization: ::prost::alloc::string::String,
    /// the incremental strategy used for that model (ex. append, merge, etc.)
    #[prost(string, tag = "10")]
    pub model_incremental_strategy: ::prost::alloc::string::String,
    /// unique identifier for the model (I believe an MD5 hash of the model name)
    #[prost(string, tag = "11")]
    pub model_id: ::prost::alloc::string::String,
    /// MD5 hash of the model's contents. This is used to determine if the model
    /// has changed since the last time it was run.
    #[prost(string, tag = "12")]
    pub hashed_contents: ::prost::alloc::string::String,
    /// the language used to write the model (ex. sql, python)
    #[prost(string, tag = "13")]
    pub language: ::prost::alloc::string::String,
    /// whether or not the model is in a group
    #[prost(bool, tag = "14")]
    pub has_group: bool,
    /// whether or not the model is contract enforced
    #[prost(bool, tag = "15")]
    pub contract_enforced: bool,
    /// the access level of the model (ex. public, private, etc.)
    #[prost(string, tag = "16")]
    pub access: ::prost::alloc::string::String,
    /// whether or not the model is versioned
    #[prost(bool, tag = "17")]
    pub versioned: bool,
    /// A reason for why the model was skipped. The valid values for this are:
    ///
    ///   cost_avoidance
    ///   upstream_failed
    ///
    #[prost(string, tag = "18")]
    pub run_skipped_reason: ::prost::alloc::string::String,
    /// A globally unique ID that is emitted at each instance of an individual
    /// model being run.
    #[prost(string, tag = "19")]
    pub run_model_id: ::prost::alloc::string::String,
    /// The resource type of the node (model, test, etc.)
    #[prost(string, tag = "20")]
    pub resource_type: ::prost::alloc::string::String,
}
impl ::prost::Name for RunModel {
    const NAME: &'static str = "RunModel";
    const PACKAGE: &'static str = "v1.public.events.fusion";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.RunModel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.RunModel".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Onboarding {
    /// This field is a toggle to enable enrichment of the message by the Vortex service.
    #[prost(message, optional, tag = "1")]
    pub enrichment: ::core::option::Option<
        super::super::super::events::vortex::VortexMessageEnrichment,
    >,
    /// Unique identifier for this event (UUID).
    /// Required.
    #[prost(string, tag = "2")]
    pub event_id: ::prost::alloc::string::String,
    /// Globally unique identifier for the fusion invocation.
    /// Required.
    #[prost(string, tag = "3")]
    pub invocation_id: ::prost::alloc::string::String,
    /// Onboarding semantics.
    ///
    /// Which screen/step
    #[prost(enumeration = "OnboardingScreen", tag = "4")]
    pub screen: i32,
    /// What happened on that screen
    #[prost(enumeration = "OnboardingAction", tag = "5")]
    pub action: i32,
    /// Only for RUN_FINISHED/STEP_COMPLETED; ignored otherwise
    #[prost(bool, tag = "6")]
    pub success: bool,
}
impl ::prost::Name for Onboarding {
    const NAME: &'static str = "Onboarding";
    const PACKAGE: &'static str = "v1.public.events.fusion";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.Onboarding".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.Onboarding".into()
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OnboardingScreen {
    ScreenUnspecified = 0,
    Welcome = 1,
    ProfileCheck = 2,
    ProfileFound = 3,
    ProfileSetup = 4,
    LinkAccount = 5,
    DbtParse = 6,
    ParseErrorAutofix = 7,
    DbtParseRetry = 8,
    ParseErrorFail = 9,
    CompileNoSa = 10,
    CompileNoSaFail = 11,
    Compile = 12,
    CompileFail = 13,
    Success = 14,
}
impl OnboardingScreen {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ScreenUnspecified => "SCREEN_UNSPECIFIED",
            Self::Welcome => "WELCOME",
            Self::ProfileCheck => "PROFILE_CHECK",
            Self::ProfileFound => "PROFILE_FOUND",
            Self::ProfileSetup => "PROFILE_SETUP",
            Self::LinkAccount => "LINK_ACCOUNT",
            Self::DbtParse => "DBT_PARSE",
            Self::ParseErrorAutofix => "PARSE_ERROR_AUTOFIX",
            Self::DbtParseRetry => "DBT_PARSE_RETRY",
            Self::ParseErrorFail => "PARSE_ERROR_FAIL",
            Self::CompileNoSa => "COMPILE_NO_SA",
            Self::CompileNoSaFail => "COMPILE_NO_SA_FAIL",
            Self::Compile => "COMPILE",
            Self::CompileFail => "COMPILE_FAIL",
            Self::Success => "SUCCESS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCREEN_UNSPECIFIED" => Some(Self::ScreenUnspecified),
            "WELCOME" => Some(Self::Welcome),
            "PROFILE_CHECK" => Some(Self::ProfileCheck),
            "PROFILE_FOUND" => Some(Self::ProfileFound),
            "PROFILE_SETUP" => Some(Self::ProfileSetup),
            "LINK_ACCOUNT" => Some(Self::LinkAccount),
            "DBT_PARSE" => Some(Self::DbtParse),
            "PARSE_ERROR_AUTOFIX" => Some(Self::ParseErrorAutofix),
            "DBT_PARSE_RETRY" => Some(Self::DbtParseRetry),
            "PARSE_ERROR_FAIL" => Some(Self::ParseErrorFail),
            "COMPILE_NO_SA" => Some(Self::CompileNoSa),
            "COMPILE_NO_SA_FAIL" => Some(Self::CompileNoSaFail),
            "COMPILE" => Some(Self::Compile),
            "COMPILE_FAIL" => Some(Self::CompileFail),
            "SUCCESS" => Some(Self::Success),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OnboardingAction {
    ActionUnspecified = 0,
    /// flow start (WELCOME)
    Initiated = 1,
    /// screen displayed
    ScreenShown = 2,
    /// parse/compile began
    RunStarted = 3,
    /// parse/compile ended (use success)
    RunFinished = 4,
    /// checkpoint reached (use success)
    StepCompleted = 5,
    /// explicit failure
    StepFailed = 6,
}
impl OnboardingAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ActionUnspecified => "ACTION_UNSPECIFIED",
            Self::Initiated => "INITIATED",
            Self::ScreenShown => "SCREEN_SHOWN",
            Self::RunStarted => "RUN_STARTED",
            Self::RunFinished => "RUN_FINISHED",
            Self::StepCompleted => "STEP_COMPLETED",
            Self::StepFailed => "STEP_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTION_UNSPECIFIED" => Some(Self::ActionUnspecified),
            "INITIATED" => Some(Self::Initiated),
            "SCREEN_SHOWN" => Some(Self::ScreenShown),
            "RUN_STARTED" => Some(Self::RunStarted),
            "RUN_FINISHED" => Some(Self::RunFinished),
            "STEP_COMPLETED" => Some(Self::StepCompleted),
            "STEP_FAILED" => Some(Self::StepFailed),
            _ => None,
        }
    }
}
