// This file is @generated by prost-build.
/// Aggregate invocation metrics.
#[derive(crate::macros::ProtoNew)]
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[::serde_with::skip_serializing_none]
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InvocationMetrics {
    #[prost(uint64, optional, tag = "1")]
    pub total_errors: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "2")]
    pub total_warnings: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub autofix_suggestions: ::core::option::Option<u64>,
}
impl crate::StaticName for InvocationMetrics {
    const FULL_NAME: &'static str = "v1.public.events.fusion.invocation.InvocationMetrics";
    const TYPE_URL: &'static str = "/v1.public.events.fusion.invocation.InvocationMetrics";
}
impl ::prost::Name for InvocationMetrics {
    const NAME: &'static str = "InvocationMetrics";
    const PACKAGE: &'static str = "v1.public.events.fusion.invocation";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.invocation.InvocationMetrics".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.invocation.InvocationMetrics".into()
    }
}
/// Structured evaluation arguments for the invocation.
#[derive(crate::macros::ProtoNew)]
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[::serde_with::skip_serializing_none]
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InvocationEvalArgs {
    /// The dbt command executed, e.g. "run", "test", "build".
    #[prost(string, tag = "1")]
    pub command: ::prost::alloc::string::String,
    /// The profile directory to load the profiles from
    #[prost(string, optional, tag = "2")]
    pub profiles_dir: ::core::option::Option<::prost::alloc::string::String>,
    /// The directory to install packages
    #[prost(string, optional, tag = "3")]
    pub packages_install_path: ::core::option::Option<::prost::alloc::string::String>,
    /// dbt target, e.g. "dev", "prod"
    #[prost(string, optional, tag = "4")]
    pub target: ::core::option::Option<::prost::alloc::string::String>,
    /// Profile name used for the invocation
    #[prost(string, optional, tag = "5")]
    pub profile: ::core::option::Option<::prost::alloc::string::String>,
    /// Vars to pass to the jinja environment. JSON blob string.
    #[prost(string, tag = "6")]
    pub vars: ::prost::alloc::string::String,
    /// Limiting number of shown rows. None means no limit; --limit -1 to remove limit
    #[prost(uint64, optional, tag = "7")]
    pub limit: ::core::option::Option<u64>,
    /// The number of threads to use
    #[prost(uint64, optional, tag = "8")]
    pub num_threads: ::core::option::Option<u64>,
    /// yaml selector
    #[prost(string, optional, tag = "9")]
    pub selector: ::core::option::Option<::prost::alloc::string::String>,
    /// Select nodes to operate on
    #[prost(string, repeated, tag = "10")]
    pub select: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Select nodes to exclude from selected nodes
    #[prost(string, repeated, tag = "11")]
    pub exclude: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Indirect selection mode
    #[prost(string, optional, tag = "12")]
    pub indirect_selection: ::core::option::Option<::prost::alloc::string::String>,
    /// Show output keys
    #[prost(string, repeated, tag = "13")]
    pub output_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Resource types to filter by
    #[prost(string, repeated, tag = "14")]
    pub resource_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Exclude nodes of a specific type
    #[prost(string, repeated, tag = "15")]
    pub exclude_resource_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Debug flag
    #[prost(bool, optional, tag = "16")]
    pub debug: ::core::option::Option<bool>,
    /// Logging format
    #[prost(string, optional, tag = "17")]
    pub log_format: ::core::option::Option<::prost::alloc::string::String>,
    /// Minimum severity for console/log file
    #[prost(string, optional, tag = "18")]
    pub log_level: ::core::option::Option<::prost::alloc::string::String>,
    /// 'log-path' for the current run, overriding 'DBT_LOG_PATH'.
    #[prost(string, optional, tag = "19")]
    pub log_path: ::core::option::Option<::prost::alloc::string::String>,
    /// The output directory for all produced assets
    #[prost(string, optional, tag = "20")]
    pub target_path: ::core::option::Option<::prost::alloc::string::String>,
    /// The directory to load the dbt project from
    #[prost(string, optional, tag = "21")]
    pub project_dir: ::core::option::Option<::prost::alloc::string::String>,
    /// Suppress all non-error logging to stdout
    #[prost(bool, optional, tag = "22")]
    pub quiet: ::core::option::Option<bool>,
    /// Write JSON artifacts to disk
    #[prost(bool, optional, tag = "23")]
    pub write_json: ::core::option::Option<bool>,
    /// Write a catalog.json file to the target directory
    #[prost(bool, optional, tag = "24")]
    pub write_catalog: ::core::option::Option<bool>,
}
impl crate::StaticName for InvocationEvalArgs {
    const FULL_NAME: &'static str = "v1.public.events.fusion.invocation.InvocationEvalArgs";
    const TYPE_URL: &'static str = "/v1.public.events.fusion.invocation.InvocationEvalArgs";
}
impl ::prost::Name for InvocationEvalArgs {
    const NAME: &'static str = "InvocationEvalArgs";
    const PACKAGE: &'static str = "v1.public.events.fusion.invocation";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.invocation.InvocationEvalArgs".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.invocation.InvocationEvalArgs".into()
    }
}
/// Invocation event holding identifying info and flattened attributes.
#[derive(crate::macros::ProtoNew)]
#[cfg_attr(any(test, feature = "test-utils"), derive(::fake::Dummy))]
#[::serde_with::skip_serializing_none]
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Invocation {
    /// UUID string for the invocation id, either as passed in via args or generated (UUIDv7 in that case).
    /// Note, that `trace_id` is the same value stored as bytes and generally preferred
    /// for correlation with other events as it is present on all telemetry records.
    #[prost(string, tag = "1")]
    pub invocation_id: ::prost::alloc::string::String,
    /// Raw command string as executed.
    #[prost(string, tag = "2")]
    pub raw_command: ::prost::alloc::string::String,
    /// Structured evaluation arguments.
    #[prost(message, optional, tag = "3")]
    pub eval_args: ::core::option::Option<InvocationEvalArgs>,
    /// Process-wide attributes.
    #[prost(message, optional, tag = "4")]
    pub process_info: ::core::option::Option<super::process::Process>,
    /// Aggregate invocation metrics.
    #[prost(message, optional, tag = "5")]
    pub metrics: ::core::option::Option<InvocationMetrics>,
}
impl crate::StaticName for Invocation {
    const FULL_NAME: &'static str = "v1.public.events.fusion.invocation.Invocation";
    const TYPE_URL: &'static str = "/v1.public.events.fusion.invocation.Invocation";
}
impl ::prost::Name for Invocation {
    const NAME: &'static str = "Invocation";
    const PACKAGE: &'static str = "v1.public.events.fusion.invocation";
    fn full_name() -> ::prost::alloc::string::String {
        "v1.public.events.fusion.invocation.Invocation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/v1.public.events.fusion.invocation.Invocation".into()
    }
}
