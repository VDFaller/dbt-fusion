/*
 * dbt Cloud API v3
 *
 * # How to use this API  The dbt Cloud API v3 contains endpoints for programmatic administration of your dbt Cloud account. With it, you can replicate resources across projects, accounts, and environments, or standardize project creation for business teams. For endpoints related to jobs and runs, refer to the [Discovery API](https://docs.getdbt.com/docs/dbt-cloud-apis/discovery-api) or [dbt Cloud API v2](https://docs.getdbt.com/dbt-cloud/api-v2#/).  The API docs are generated from an openapi spec defined in the [dbt-cloud-openapi-spec](https://github.com/dbt-labs/dbt-cloud-openapi-spec/blob/master/openapi-v3.yaml) repository. If you find issues in these docs or have questions about using the dbt Cloud API, please open an issue in the dbt-cloud-openapi-spec repo or contact support@getdbt.com.  ## Authentication  To authenticate an application with the dbt Cloud API, navigate to the Account Settings page and go to Personal Tokens from the left sidebar. Create one if you don't have one already. If you cannot access this page, confirm that your dbt Cloud account has access to the API, and that you are using the hosted version of dbt Cloud. If dbt Cloud is running inside of a VPC in an Enterprise account, contact your account manager for help finding your account-scoped Personal Access Token.  Once you've found your Personal Access Token (PAT) for your account, use it in the Authorization header of requests to the dbt Cloud API. Be sure to include the `Token` prefix in the Authorization header, or the request will fail with a \"401 Unauthorized\" error.  *Note: `Bearer` can be used in place of `Token` in the Authorization header. Both syntaxes are equivalent.*  **Headers** ``` Accept: application/json Authorization: Token <your token> ```  ## Pagination  All top-level API resources support bulk fetches using the \"list\" or `GET` API methods. These API methods accept `limit` and `offset` query parameters that you can use together to paginate results and return a subset of those results.  * Offset: Specifies how many records to skip. Can be an integer 0 and higher. * Limit: Specifies the maximum records you want to retrieve in a single request. Can be an integer up to 100. This limit makes responses easier to handle for servers and people.  Endpoints that support pagination include some useful extra information about the pagination state. For example:  ```json {   data: [...],   extra: {     // How the results were filtered     filters: {...},     // The order of the results     order_by: \"id\",     // The pagination state     pagination: {       // The number of records returned in this response       count: 5,       // The total number of available records       total_count: 10,     }    } } ````  ## Example request  The following example uses the list projects endpoint to list the projects that your token is authorized to access. This request skips the first 10 projects and lists the next 10 projects. Be sure to replace `<YOUR_TOKEN>` in the Authorization header with your actual API token and `<YOUR_ACCOUNT_ID>` with your actual account ID.  ```bash curl --request GET \\   --url 'https://cloud.getdbt.com/api/v3/accounts/<YOUR_ACCOUNT_ID>/projects/?limit=10&offset=5' \\   --header 'Content-Type: application/json' \\   --header 'Authorization: Token <YOUR_TOKEN>' ```
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: support@getdbt.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct Project {
    /// The name of the project
    #[serde(rename = "name")]
    pub name: String,
    /// The account the project is associated with
    #[serde(rename = "account_id")]
    pub account_id: i32,
    /// The description of the project
    #[serde(rename = "description", skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// The active connection
    #[serde(rename = "connection_id", skip_serializing_if = "Option::is_none")]
    pub connection_id: Option<i32>,
    /// The active repository
    #[serde(rename = "repository_id", skip_serializing_if = "Option::is_none")]
    pub repository_id: Option<i32>,
    /// The active semantic layer configuration
    #[serde(
        rename = "semantic_layer_config_id",
        skip_serializing_if = "Option::is_none"
    )]
    pub semantic_layer_config_id: Option<i32>,
    /// A value of 1 means this entity is active and a value of 2 means this entity is deleted
    #[serde(rename = "state")]
    pub state: i32,
    /// The path in the associated repository where a dbt project can be found
    #[serde(
        rename = "dbt_project_subdirectory",
        skip_serializing_if = "Option::is_none"
    )]
    pub dbt_project_subdirectory: Option<String>,
    /// The job used for docs generation
    #[serde(rename = "docs_job_id", skip_serializing_if = "Option::is_none")]
    pub docs_job_id: Option<i32>,
    /// The job used for source freshness generation
    #[serde(rename = "freshness_job_id", skip_serializing_if = "Option::is_none")]
    pub freshness_job_id: Option<i32>,
    /// The type of the project  * `0` - DEFAULT * `1` - HYBRID
    #[serde(rename = "type")]
    pub r#type: models::Type24eEnum,
}

impl Project {
    pub fn new(name: String, account_id: i32, state: i32, r#type: models::Type24eEnum) -> Project {
        Project {
            name,
            account_id,
            description: None,
            connection_id: None,
            repository_id: None,
            semantic_layer_config_id: None,
            state,
            dbt_project_subdirectory: None,
            docs_job_id: None,
            freshness_job_id: None,
            r#type,
        }
    }
}
